webpackJsonp([0x79972e708824],{385:function(e,n){e.exports={data:{markdownRemark:{html:'<p>ECMAScript5 introduced <code>Date.now()</code>, a method that returns the milliseconds elapsed since <code>1 January 1970 00:00:00 UTC</code> up until now as a <code>Number</code>. <code>Date.now()</code> is the fastest way to record a timestamp in JavaScript<sup><a href="https://jsperf.com/date-now-vs-new-date-gettime/11">[1]</a>, <a href="http://jsperf.com/date-now-vs-new-date-gettime/8">[2]</a></sup> and as such, usage will continue to increase as developers become educated in speed improvements.</p>\n<p>While speed improvements are important, storing Unix / Epoch timestamps in MongoDB come with a quirk; MongoDB only support BSON native date objects. What this means as a developer is that the <a href="http://docs.mongodb.org/manual/reference/operator/aggregation-date">Date Aggregation Operators</a> such as <code>$dayOfWeek</code> and <code>$dayOfYear</code> are unusable natively. This poses a challenge when trying to obtain time series reports such as week over week reports, month over month reports, year over year reports, etc. There are two tricks one can use to solving this problem.</p>\n<h3>Sample data</h3>\n<p>For the proceeding examples, we will assume our database has a collection called <code>shipments</code> and documents that look like this:</p>\n<pre><code class="language-json">// documents in the shipment collection\n{\n  _id : "ef0581de-7cae-4e18-8c25-e6ea36489793",\n  contents : "Microsoft Glass 19",\n},\n{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  contents : "Apple iPhone 7",\n  sentAt : 1444438552674\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  contents : "Samsung Galaxy 6 Edge+",\n  sentAt : 1436684400000\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  contents : "Nokia 8850",\n  sentAt : 920880000000\n}\n</code></pre>\n<h3>Approach 1</h3>\n<p>The first approach can be achieved by using an addition aggregation to convert the timestamp into a BSON object in memory then utilize MongoDB’s Date Aggregation Operators to obtain the desired result. Below is an example of this approach.</p>\n<p>MongoDB query | MongoDB result</p>\n<pre><code class="language-json">// Finds all sent shipments\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  contents : "Apple iPhone 7",\n  sentAt : 1444438552674\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  contents : "Samsung Galaxy 6 Edge+",\n  sentAt : 1436684400000\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  contents : "Nokia 8850",\n  sentAt : 920880000000\n}\n</code></pre>\n<pre><code class="language-json">// Finds all sent shipments, returning the BSON timestamp\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } },\n    { $project : { "mongoTimestamp" : {$add : [new Date(0), "$sentAt"] } } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  mongoTimestamp : ISODate("2015-07-02T22:09:48.911Z")\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  mongoTimestamp : ISODate("2015-07-02T22:09:48.911Z")\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  mongoTimestamp : ISODate("2015-07-02T22:09:48.911Z")\n}\n</code></pre>\n<pre><code class="language-json">// Finds all sent shipments, returning the year shipped\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } },\n    { $project : { "mongoTimestamp" : { $add : [new Date(0), "$sentAt"] } } },\n    { $project : { "year_shipped" : { $year : "$mongoTimestamp" } } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  year_shipped : 2015\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  year_shipped : 2015\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  year_shipped : 1999\n}\n</code></pre>\n<pre><code class="language-json">// Finds counts of all sent shipments, grouped by year\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } },\n    { $project : { "mongoTimestamp" : { $add : [new Date(0), "$sentAt"] } } },\n    { $project : { "year_shipped" : { $year : "$mongoTimestamp" } } },\n    { $group : { _id : {year_shipped : "$year_shipped" } , number : { $sum : 1 } } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : { year_shipped : 2015 },\n  number: 2\n},\n{\n  _id : { year_shipped : 1999 },\n  number: 1\n}\n</code></pre>\n<h3>Approach 2</h3>\n<p>Approach 1 above works fine and is probably the preferred method, however in many production type situations the query is stringified by a framework or application prior to submitting / sending the query. If this were true in the above example, <code>{ $add : [new Date(0), "$sentAt"] }</code> would have been converted to <code>{ $add : ["Wed Dec 31 1969 16:00:00 GMT-0800 (PST)", "$sentAt"] }</code> prior to submission, causing MongoDB to return the error message <code>"errmsg" : "exception: $add only supports numeric or date types, not String"</code>.</p>\n<p>A workaround to the above problem can be had using the <code>n - (n % )</code> modulo trick. This equation allows us to round any number to the nearest interval. For example, if we had a list of numbers such as <code>105.2</code>, <code>251</code> and <code>170.1</code> and we wanted to round to the nearest hundreth, performing the above operations on each number using the interval of 100 would result in <code>100</code>, <code>200</code>, and <code>100</code>. We can extrapolate this logic and apply it to days, weeks, months, quarters, years, etc. Note, one limitation of this method is that it does not honor daylight savings time.</p>\n<p>Now, let’s apply Approach 2 to the same shipments example. For reference, one year is equivalent to 31,556,908,800 milliseconds.</p>\n<p>MongoDB query | MongoDB result</p>\n<pre><code class="language-json">// Finds all sent shipments\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  contents : "Apple iPhone 7",\n  sentAt : 1444438552674\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  contents : "Samsung Galaxy 6 Edge+",\n  sentAt : 1436684400000\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  contents : "Nokia 8850",\n  sentAt : 920880000000\n}\n</code></pre>\n<pre><code class="language-json">// Finds all sent shipments, returning the year shipped in milliseconds\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } },\n    { $project : { "year_shipped" :\n      { $subtract : ["$sentAt", {$mod : ["$sentAt", 31556908800] } ] },\n    } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : "8b0b5ec1-f6c2-4637-a560-75d96ec6f19b",\n  year_shipped : 1420060896000\n},\n{\n  _id : "2643046-92c3-4fa9-aa51-c6f3e668bde5",\n  year_shipped : 1420060896000\n},\n{\n  _id : "a3b673ee-17f9-4e9c-aa68-a70fac19ea10",\n  year_shipped : 915150355200\n}\n</code></pre>\n<pre><code class="language-json">// Finds all shipments that have been sent and groups by year\ndb.shipments.aggregate(\n  [\n    { $match : { "sentAt" : { "$exists" : 1 } } },\n    { $project : { "year_shipped" :\n      { $subtract : ["$sentAt", {$mod : ["$sentAt", 31556908800] } ] },\n      { $group : { _id : {year_shipped : "$year_shipped" } , number : { $sum : 1 } } }\n    } }\n  ]\n)\n</code></pre>\n<p> |</p>\n<pre><code class="language-json">{\n  _id : { year_shipped : 1420060896000 },\n  number: 2\n},\n{\n  _id : { year_shipped : 915150355200 },\n  number: 1\n}\n</code></pre>',frontmatter:{date:"1444806000000",path:"/blog/how-to-generate-time-series-week-over-week-year-over-year-aggregations-in-mongodb-using-unix-epoch-timestamps-tutorial-and-example",title:"How to generate time series aggregations in MongoDB using Unix / Epoch timestamps (week over week, year over year, etc. tutorial and example)"}}},pathContext:{}}}});
//# sourceMappingURL=path---blog-how-to-generate-time-series-week-over-week-year-over-year-aggregations-in-mongodb-using-unix-epoch-timestamps-tutorial-and-example-ed016f43e0a4d2c38733.js.map